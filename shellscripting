Why Scripting?

Automation goals: Speed and Accuracy

1. Speed
2. Accuracy, no human errors
3. Consistency
4. Scalability, can work for infinite number of servers
5. Documentaion. What happened including history
6. Reusability.

Where to store scripts?

1. Security
2. Can't share with others
3. Version control.

Repositories/Version Control System

Centralised vs Decentralised/Distributed
========================================
Centralised capital

1. Single point of failure
2. Pollution
3. Over crowd
4. Social unrest
5. Resources shortage

Mumbai -> Movies and financial, transporation
Chenai -> Manfacturing
Bangalore -> IT
Kolkata -> Manfacturing

SVN -> Sub version control

Central Library
=================
1. What if library is closed on holidays?
2. What if library building collapsed?
3. Crowd and their facilities

LMS
=====
local libraries

1. they can rent books to us

Git is a concept -> Linus Torwalds

GitHub -> All opensource products code is here
Bitbucket
Gitlab


git clone <repo-url> -> code will be downloaded into our laptop

normal folder vs git repo

git repo will have .git as hidden directory

branching -> create another duplicate copy, do the changes the here and then take the approval from colleagues and team member, test them as well. if everything is fine then merge with main branch

IDE tool -> Integrated development environment

Eclipse
IntelliJ
Vs code
sublime editor
notepad++
Textpad

vscode -> workspace -> staging area -> commit to local repo -> central repo

20 files -> 10 files completed changes, 10 files middle

what is staging area?
it is a temp area. where we can stage the required files for commit..still we have a chance to take back into workspace..

what is local commit?
commit into local repository nothing but laptop. commit time will be logged, who commited will be logged, why they commited also will be logged

push to central/remote repo?

push to central repo..others can just run git pull(pull the changes from central to local repo)

git clone vs git pull
=====================
clone -> first time downloading the code
pull -> just pull the changes

staging area -> git add <file-name>
local commit -> git commit -m "first commit, hello world started"
push to central repo -> git push origin main

1. signup to github
2. install vs code
3. open folder in vs code where you store all repos
create repo in github
4. clone the repo
5. do something
6. add to staging area
7. commit to local repo
8. push to central repo

#!/bin/bash -> Shebang

it should be the first line in shell script, it is the interpret to check the syntax of the script and execute them

k shell, c shell, z shell, etc.

bash shell

sh == bash

file extension -> .sh

git add . -> all changes will be staged.

git add . ; git commit -m "some message"; git push origin main

Don't do or edit anything inside server.

Let x=0, y=1 -> variables
derive the formula
final substitute

variable is a container that holds something/value.

DRY -> don't repeat yourself
Reusability
Flexibilty -> prevents accidental edits
Readability -> 
Maintanance

VAR_NAME=VALUE

clone the repo
add to staging area -> git add
commit to local -> git commit -m "message"

git config --global user.name ""
git config --global user.email ""

git log

push to central -> git push origin main
sign in with browser

#!/bin/bash

DRY, reusability, maintainability
change is single place reflects everywhere you refer

VAR_NAME=VALUE

$VAR_NAME
${VAR_NAME}

sh 04-variables.sh Trump Putin

$1=Trump
$2=Putin

ENV variables
==============
export COURSE="DevSecOps with AWS" -> ENV variables, this variable is valid until this process is alive, it is accessible to sub process also

~/.bashrc

enter the variable with value in this file
source .bashrc

how do you run a command inside shell script and take the output

script start time
script end time
executed in end time - start time seconds

VAR_NAME=$(command)

1. declare inside script
2. pass the values as args
3. read command
4. ENV variables
5. dynamic execution of commands


Variables
Data types
Conditions
Functions
Loops
Error handling

Data types
============
gopikrishna -> name
13 -> number

12.22 -> decimal
12 -> integer
3+4i -> complex number
log34 -> logarithm

integer -> -33,768 to 33,768
string -> devops aws shell
boolean -> true or false
char -> a b c d
float -> 33.34
decimal -> 33.836419859
long -> 9873471328

int i=0, j=0

VAR_NAME=VALUE

int i=58914710.59147590

there are no explicit data types in shell script. everything in shell is considered as string..

copied code from 4 to 5..

long i = 15960km/hr
long i = 158967.547km/hr

Name=DevOps
Name=("Linux" "Shell" "Docker")

0 1 2 3
index starts from 0


Variables
===========
1. declare and assign values inside the script
2. pass from outside as args
3. read command
4. ENV variables
5. special variables

datatypes
==========
fruits=("Apple" "Banana")

"$VAR_NAME"
"${VAR_NAME}"

index starts from 0

conditions
===============

umbrella sunglasses

alogorithm or thinking is important. no code at this stage just plain english

if/else, when

if it is raining
	take umbrella
else
	take sunglasses
	
if(expression){
	these statements if expression is true
}
else{
	these statements if expression is false
}

! is negative

if(!expression){ # false*false = true
	these statements if expression is true
}
else{
	these statements if expression is false
}

if [ condition ]; then
    # Commands to execute if condition is true
fi


if [ condition ]; then
    # Commands to execute if condition is true
else
    # Commands to execute if condition is false
fi

number < 10
given number is less than 10
else
given number is greater than or equal to 10

if a number is divided by 2 then even otherwise odd

15/2

take the number
divide by 2 and get the reminder
if it is equal to 0 then it is even
otherwise it is odd

write a script to know a number is prime or not

Exit status
=============
dnf install mysql -y

$? -> previous command exit status

0 -> SUCCESS
1-127 -> FAILURE

check if the user has root access or not
if root access then proceed
otherwise stop and tell them to run with root access

dnf install mysql -y

check exit status, if 0 success
otherwise show the user it is failed


if id -u is 0 then proceed
otherwise stop

if there is error in script, proceed or stop?

mysql nginx mongodb-mongosh

scripting/programming
=====================
1. keep less lines more performance
2. readability
3. DRY, try to reuse the code

functions
====================
takes some inputs and gives some output

1. call it
2. provide inputs if required

func_name(){

}

func_name

Red - "\e[31m"

SUCCESS - Green
FAILURE - Red
SKIP - Yellow

Logs
==================
/var/log/shellscript-logs/15-colors.log

Redirections
===================
1 -> success
2 -> failure
& -> success/failure
